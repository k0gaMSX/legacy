<HTML><BODY>

<H5><A name="p1"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-1:</A></H5>
<BR><P>

<STRONG><H3>CHAPTER 5</STRONG> INSTRUCTION SET</H3>
<H4>5.1 INTRODUCTION</H4>
The Z380<SUP>(TM)</SUP>  CPU instruction set is a superset of the Z80 CPU
and the Z180 MPU; the Z380 CPU is opcode compatible
with the Z80 CPU/ Z180 MPU. Thus, a Z80/Z180 program
can be executed on a Z380 CPU without modification. The
instruction set is divided into 12 groups by function:
<P>

<UL>
<BR><LI> 8-Bit Load/ Exchange Group
<BR><LI> 16/ 32-Bit Load, Exchange, SWAP and Push/ Pop Group
<BR><LI> Block Transfers, and Search Group
<BR><LI> 8-Bit Arithmetic and Logic Operations
<BR><LI> 16/ 32-Bit Arithmetic Operations
<BR><LI> 8-Bit Bit Manipulation, Rotate and Shift Group
<BR><LI> 16-Bit Rotates and Shifts
<BR><LI> Program Control Group
<BR><LI> Input and Output Operations for External I/O Space
<BR><LI> Input and Output Operations for Internal I/O Space
<BR><LI> CPU Control Group
<BR><LI> Decoder Directives
</UL>
<P>
<H3>5.2 PROCESSOR FLAGS</H3>
The Flag register contains six bits of status information that
are set or cleared by CPU operations (Figure 5-1). Four of
these bits are testable (C, P/V, Z, and S) for use with
conditional jump, call, or return instructions. Two flags are
not testable (H and N) and are used for binary-coded
decimal (BCD) arithmetic.
<BR><P>


The Flag register provides a link between sequentially
executed instructions, in that the result of executing one
instruction may alter the flags, and the resulting value of the
flags can be used to determine the operation of a subsequent
instruction. The program control instructions, whose
operation depends on the state of the flags, are the Jump,
Jump Relative, subroutine Call, Call Relative, and subroutine
Return instructions; these instructions are referred to
as conditional instructions.

<BR><P>
<TABLE BORDER>
<TR> <TD> S <TD> Z <TD> X <TD> H <TD> X <TD>P/V <TD> N <TD> C </TR>
<TR> <TD> 7 <TD> 6 <TD> 5 <TD> 4 <TD> 3 <TD> 2  <TD> 1 <TD> 0 </TR>
</TABLE>
 Figure 5-1. Flag Register
<BR><P>

This chapter describes the instruction set of the Z380 CPU.
Flags and condition codes are discussed in relation to the
instruction set. Then, the interpretability of instructions and
trap are discussed. The last part of this chapter is a
detailed description of each instruction, listed in alphabetical
order by mnemonic. This section is intended as a
reference for Z380 CPU programmers. The entry for each
instruction contains a complete description of the instruction,
including addressing modes, assembly language
mnemonics, and instruction opcode formats.
<P>

<H5><A name="p2"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-2:</A></H5>
<BR><P>

<H4>5.2.1 Carry Flag (C)</H4>
The Carry flag is set or cleared depending on the operation
being performed. For add instructions that generate a
carry and subtract instruction generating a borrow, the
Carry flag is set to 1. The Carry flag is cleared to 0 by an add
that does not generate a carry or a subtract that generates
no borrow. This saved carry facilitates software routines for
extended precision arithmetic. The multiply instructions
use the Carry flag to signal information about the precision
of the result. Also, the Decimal Adjust Accumulator (DAA)
instruction leaves the Carry flag set to 1 if a carry occurs
when adding BCD quantities.
<BR><P>

For rotate instructions, the Carry flag is used as a link
between the least significant and most significant bits for
any register or memory location. During shift instructions,
the Carry flag contains the last value shifted out of any
register or memory location. For logical instructions the
Carry flag is cleared. The Carry flag can also be set and
complemented with explicit instructions.
<BR><P>

<H4>5.2.2 Add/ Subtract Flag (N)</H4>
The Add/ Subtract flag is used for BCD arithmetic. Since
the algorithm for correcting BCD operations is different for
addition and subtraction, this flag is used to record when
an add or subtract was last executed, allowing a subsequent
Decimal Adjust Accumulator instruction to perform
correctly. See the discussion of the DAA instruction for
further information.
<BR><P>

<H4>5.2.3 Parity/Overflow Flag (P/V)</H4>
This flag is set to a particular state depending on the
operation being performed.
<BR><P>

For signed arithmetic, this flag, when set to 1, indicates that
the result of an operation on two's complement numbers
has exceeded the largest number, or less than the smallest
number, that can be represented using two's complement
notation. This overflow condition can be determined by
examining the sign bits of the operands and the result.
<BR><P>

The P/V flag is also used with logical operations and rotate
instructions to indicate the parity of the result. The of bits
set to 1 in a byte are counted. If the total is odd, this flag is
reset indicates odd parity (P = 0). If the total is even, this
flag is set indicates even parity (P = 1).
<BR><P>

During block search and block transfer instructions, the P/V
 flag monitors the state of the Byte Count register (BC).
When decrementing the byte counter results in a zero
value, the flag is cleared to 0; otherwise the flag is set to 1.
<BR><P>

During Load Accumulator with I or R register instruction,
the P/V flag is loaded with the IEF2 flag. For details on this
topic,. refer to Chapter 6, "Interrupts and Traps."
<BR><P>

When a byte is inputted to a register from an I/O device
addressed by the C register, the flag is adjusted to indicate
the parity of the data.
<BR><P>

<H4>5.2.4 Half-Carry Flag (H)
</H4>
The Half-Carry flag (H) is set to 1 or cleared to 0 depending
on the carry and borrow status between bits 3 and 4 of an
8-bit arithmetic operation and between bits 11 and 12 of a
16-bit arithmetic operation. This flag is used by the Deci-mal
Adjust Accumulator instruction to correct the result of
an addition or subtraction operation on packed BCD data.
<BR><P>

<H4>5.2.5 Zero Flag (Z)
</H4>
The Zero flag (Z) is set to 1 if the result generated by the
execution of certain instruction is a zero.
<BR><P>

For arithmetic and logical operations, the Zero flag is set to
1 if the result is zero. If the result is not zero, the Zero flag
is cleared to 0.
<BR><P>

For block search instructions, the Zero flag is set to 1 if a
comparison is found between the value in the Accumulator
and the memory location pointed to by the contents of the
register pair HL.
<BR><P>

When testing a bit in a register or memory location, the Zero
flag contains the complemented state of the tested bit (i. e.,
the Zero flag is set to 1 if the tested bit is a 0, and vice-versa).
<BR><P>

For block I/O instructions, if the result of decrements B is
zero, the Zero flag is set to 1; otherwise, it is cleared to 0.
Also, for byte inputs to registers from I/O devices ad-dressed
by the C register, the Zero flag is set to 1 to
indicate a zero byte input.
<BR><P>

<H4>5.2.6 Sign Flag (S)
</H4>
The Sign flag (S) stores the state of the most significant bit
of the result. When the Z380 CPU performs arithmetic
operation on signed numbers, binary two's complement
notation is used to represent and process numeric infor-mation.
A positive number is identified by a 0 in the most
significant bit. A negative number is identified by a 1 in the
most significant bit.
<BR><P>

When inputting a byte from an I/O device addressed by the
C register to a CPU register, the Sign flag indicates either
positive (S = 0) or negative (S = 1) data.
<BR><P>

<H5><A name="p3"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-3:</A></H5>
<BR><P>

<H4>5.2.7 Condition Codes
</H4>
The Carry, Zero, Sign, and Parity/ Overflow flags are used
to control the operation of the conditional instructions. The
operation of these instructions is a function of the state of
one of the flags. Special mnemonics called condition
codes are used to specify the flag setting to be tested
during execution of a conditional instruction; the condition
codes are encoded into a 3-bit field in the instruction
opcode itself.
<BR><P>
Table 5-1 lists the condition code mnemonic, the flag
setting it represents, and the binary encoding for each
condition code.
<BR><P>
Table 5-1. Condition codes
<BR><P>

<TABLE BORDER>
Condition Codes for Jump, Call, and Return Instructions
<TR><TD>Mnemonic<TD>Meaning <TD>Flag Setting <TD>Binary Code </TR>

<TR><TD>NZ     <TD>Not Zero*       <TD>Z = 0      <TD>000  </TR>
<TR><TD>Z      <TD>Zero*           <TD>Z = 1      <TD>001  </TR>
<TR><TD>NC     <TD>No Carry*       <TD>C = 0      <TD>010  </TR>
<TR><TD>C      <TD>Carry*          <TD>C = 1      <TD>011  </TR>
<TR><TD>NV     <TD>No Overflow     <TD>V = 0      <TD>100  </TR>
<TR><TD>PO     <TD>Parity Odd      <TD>V = 0      <TD>100  </TR>
<TR><TD>V      <TD>Overflow        <TD>V = 1      <TD>101  </TR>
<TR><TD>PE     <TD>Parity Even     <TD>V = 1      <TD>101  </TR>
<TR><TD>NS     <TD>No Sign         <TD>S = 0      <TD>110  </TR>
<TR><TD>P      <TD>Plus            <TD>S = 0      <TD>110  </TR>
<TR><TD>S      <TD>Sign            <TD>S = 1      <TD>111  </TR>
<TR><TD>M      <TD>Minus           <TD>S = 1      <TD>111  </TR>
</TABLE>
*Abbreviated set
<BR><P>

Condition Codes for Jump Relative and Call Relative Instructions
<TABLE BORDER>
<TR><TD>Mnemonic <TD>Meaning <TD>Flag Setting <TD>Binary Code
</TR><BR>
<TR><TD>NZ     <TD>Not Zero   <TD>Z = 0      <TD>100      </TR>
<TR><TD>Z      <TD>Zero       <TD>Z = 1      <TD>101      </TR>
<TR><TD>NC     <TD>No Carry   <TD>C = 0      <TD>110      </TR>
<TR><TD>C      <TD>Carry      <TD>C = 1      <TD>111      </TR>
</TABLE>
<BR><P>

<H5><A name="p4"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-4:</A></H5>
<BR><P>

<H3>5.3 SELECT REGISTER</H3>
The Select Register (SR) controls the register set selection
and the operating modes of the Z380 CPU. The reserved
bits in the SR are for future expansion; they will always read
as zeros and should be written with zeros for future
compatibility. Access to this register is done by using the
newly added LDCTL instruction. Also, some of the instructions
like EXX, IM p, and DI/ EI change the bit( s). The SR
was shown in Figure 5-2.
<BR><P>

<TABLE BORDER>

<TR> <TH> YSR </TH>
          <TH> XSR </TH> </TR>
<TR>
     <TD> <TABLE BORDER>
     <TR> <TD> Reserved (0)</TD> <TD> IYBANK </TD> <TD> IYP </TD> </TR>
     <TR> <TD> 31 30 29 28 27 </TD> <TD> 26 25 </TD> <TD> 24 </TD> </TR>
     </TABLE> </TD>
         <TD> <TABLE BORDER>
         <TR> <TD> Reserved (0)</TD> <TD> IXBANK </TD> <TD> IXP </TD> </TR>
         <TR> <TD> 31 30 29 28 27 </TD> <TD> 26 25 </TD> <TD> 24 </TD> </TR>
         </TABLE> </TD> </TR>
</TABLE>
<BR> <P>
<TABLE BORDER>

<TR> <TH> DSR </TH>
          <TH>     </TH> </TR>
<TR>
     <TD> <TABLE BORDER>
     <TR> <TD> Reserved (0)</TD> <TD> MAINBANK </TD> <TD> ALT </TD> </TR>
     <TR> <TD> 15 14 13 12 11 </TD> <TD> 10 9 </TD> <TD> 8 </TD> </TR>
     </TABLE> </TD>
         <TD> <TABLE BORDER>
         <TR> <TD> XM </TD> <TD> LW </TD> <TD> IEF1 </TD> <TD> IM </TD>
                           <TD> 0 </TD>  <TD> LCK </TD> <TD> AFP </TD> </TR>
         <TR> <TD> 7  </TD> <TD> 6  </TD> <TD> 5    </TD> <TD> 4 3 </TD>
                           <TD> 2 </TD>  <TD> 1   </TD> <TD> 0   </TD> </TR>
         </TABLE> </TD> </TR>
</TABLE>
<br>
Figure 5-2. Select Register
<BR><P>

<H4>5.3.1. IY Bank Select (IYBANK)
</H4>
This 2-bit field selects the register set to be used for the IY
and IY' registers. This field can be set independently of the
register set selection for the other Z380 CPU registers.
Reset selects Bank 0 for IY and IY'.
<BR><P>

<H4>5.3.2. IY or IY' Register Select (IY')
</H4>
This bit controls and reports whether IY or IY' is the
currently active register. IY is selected when this bit is
cleared, and IY' is selected when this bit is set. Reset
clears this bit, selecting IY.
<BR><P>

<H4>5.3.3. IX Bank Select (IXBANK)
</H4>
This 2-bit field selects the register set to be used for the IX
and IX' registers. This field can be set independently of the
register set selection for the other Z380 CPU registers.
Reset selects Bank 0 for IX and IX'.
<BR><P>

<H4>5.3.4. IX or IX' Register Select (IX')
</H4>
This bit controls and reports whether IX or IX' is the
currently active register. IX is selected when this bit is
cleared, and IX' is selected when this bit is set. Reset
clears this bit, selecting IX.
<BR><P>

<H4>5.3.5. Main Bank Select (MAINBANK)
</H4>
This 2-bit field selects the register set to be used for the A,
F, BC, DE, HL, A', F', BC', DE', and HL' registers. This field
can be set independently of the register set selection for
the other Z380 CPU registers. Reset selects Bank 0 for
these registers.
<BR><P>

<H4>5.3.6. BC/ DE/ HL or BC'/ DE'/ HL' Register Select (ALT)
</H4>
This bit controls and reports whether BC/ DE/ HL or BC'/ DE'/
HL' is the currently active bank of registers. BC/ DE/ HL is
selected when this bit is cleared, and BC'/ DE'/ HL' is
selected when this bit is set. Reset clears this bit, selecting
BC/ DE/ HL.
<BR><P>


<H4>5.3.7. Extended Mode (XM)
</H4>
This bit controls the Extended/ Native mode selection for
the Z380 CPU. This bit is set by the SETC XM instruction.
This bit can not be reset by software, only by Reset. When
this bit is set, the Z380 CPU is in Extended mode. Reset
clears this bit, and the Z380 CPU is in Native mode.
<BR><P>

<H5><A name="p5"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-5:</A></H5>
<BR><P>

<H4>5.3.8. Long Word Mode (LW)
</H4>
This bit controls the Long Word/ Word mode selection for
the Z380 CPU. This bit is set by the SETC LW instruction
and cleared by the RESC LW instruction. When this bit is
set, the Z380 CPU is in Long Word mode; when this bit is
cleared the Z380 CPU is in Word mode. Reset clears this
bit. Note that individual Word load and exchange instructions
may be executed in either Word or Long Word mode
using the DDIR W and DDIR LW decoder directives.
<BR><P>

<H4>5.3.9. Interrupt Enable Flag (IEF)
</H4>
This bit is the master Interrupt Enable for the Z380 CPU.
This bit is set by the EI instruction and cleared by the DI
instruction, or on acknowledgment of an interrupt request.
When this bit is set, interrupts are enabled; when this bit is
cleared, interrupts are disabled. Reset clears this bit.
<BR><P>

<H4>5.3.10. Interrupt Mode (IM)
</H4>
This 2-bit field controls the interrupt mode for the /INT0
interrupt request. These bits are controlled by the IM
instructions (00 = IM 0, 01 = IM 1, 10 = IM 2, 11 = IM 3).
Reset clears both of these bits, selecting Interrupt Mode 0.
<BR><P>

<H4>5.3.11. Lock (LCK)
</H4>
This bit controls the Lock/ Unlock status of the Z380 CPU.
This bit is set by the SETC LCK instruction and cleared by
the RESC LCK instruction. When this bit is set, no bus
requests will be accepted, providing exclusive access to
the bus by the Z380 CPU. When this bit is cleared, the Z380
CPU will grant bus requests in the normal fashion. Reset
clears this bit.
<BR><P>

<H4>5.3.12. AF or AF' Register Select (AF')
</H4>
This bit controls and reports whether AF or AF' is the
currently active pair of registers. AF is selected when this
bit is cleared, and AF' is selected when this bit is set. Reset
clears this bit, selecting AF.
<BR><P>

<H3>5.4 INSTRUCTION EXECUTION AND EXCEPTIONS
</H3>
Three types of exception conditions -- interrupts, trap, and
Reset -- can alter the normal flow of program execution.
Interrupts are asynchronous events generated by a device
external to the CPU; peripheral devices use interrupts to
request service from the CPU. Trap is a synchronous event
generated internally in the CPU by executing undefined
instructions. Reset is an asynchronous event generated by
outside circuits. It terminates all current activities and puts
the CPU into a known state. Interrupts and Traps are
discussed in detail in Chapter 6, and Reset is discussed in
detail in Chapter 7. This section examines the relationship
between instructions and the exception conditions.
<BR><P>

<H4>5.4.1 Instruction Execution and Interrupts
</H4>
When the CPU receives an interrupt request, and it is
enabled for interrupts of that class, the interrupt is normally
processed at the end of the current instruction. However,
the block transfer and search instructions are designed to
be interruptible so as to minimize the length of time it takes
the CPU to respond to an interrupt. If an interrupt request
is received during a block move, block search, or block
I/O instruction, the instruction is suspended after the
current iteration. The address of the instruction itself, rather
than the address of the following instruction, is saved on
the stack, so that the same instruction is executed again
when the interrupt handler executes an interrupt return
instruction. The contents of the repetition counter and the
registers that index into the block operands are such that,
after each iteration, when the instruction is reissued upon
returning from an interrupt, the effect is the same as if the
instruction were not interrupted. This assumes, of course,
that the interrupt handler preserves the registers.
<BR><P>


<H4>5.4.2 Instruction Execution and Trap
</H4>
The Z380 MPU generates a Trap when an undefined
opcode is encountered. The action of the CPU in response
to Trap is to jump to address 00000000H with the status
bit( s) set. This response is similar to the Z180 MPU's action
on execution of an undefined instruction. The Trap is
enabled immediately after reset, and it is not maskable.
This feature can be used to increase software reliability or
to implement "extended" instructions. An undefined opcode
can be fetched from the instruction stream, or it can
be returned as a vector in an interrupt acknowledge
transaction in Interrupt mode 0.
<BR><P>

Since it jumps to address 00000000H, it is necessary to
have a Trap handling routine at the beginning of the
program if processing is to proceed. Otherwise, it behaves
just like a reset for the CPU. For a detailed description, refer
to Chapter 6.
<BR><P>

<H5><A name="p6"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-6:</A></H5>
<BR><P>

<H3>5.5 INSTRUCTION SET FUNCTIONAL GROUPS
</H3>
This section presents an overview of the Z380 instruction
set, arranged by functional groups. (See Section 5.5 for an
explanation of the notation used in Tables 5-2 through 5-11).
<BR><P>

<H4>5.5.1 8-Bit Load/ Exchange Group
</H4>
This group of instructions (Table 5-2) includes load instructions
for transferring data between byte registers, transferring
data between a byte register and memory, and loading
immediate data into byte register or memory. For the
supported source/ destination combinations, refer to Table
5-3.
<BR><P>

An Exchange instruction is available for swapping the
contents of the accumulator with another register or with
memory, as well as between registers. Also, exchange
instructions are available which swap the contents of the
register in the primary register bank and auxiliary register
bank.
<BR><P>

The instruction in this group does not affect the flags.
<BR><P>

<TABLE BORDER><CAPTION ALIGN=TOP>
Table 5-2. 8-Bit Load Group Instructions
</CAPTION>
<TR>
     <TH>Instruction Name  <TH>  Format
          <TH>  Note  </TR>
<TR> <TD> Exchange with Accumulator <TD> EX A, r <TD></TD> </TR>
<TR> <TD></TD>           <TD> EX A,( HL) <TD></TD> </TR>
<TR> <TD>Exchange r and r' <TD>EX r, r' <TD>r= A, B, C, D, E, H or L </TR>
<TR> <TD>Load Accumulator <TD>LD A,src  <TD>See Table 5-3 </TR>
<TR> <TD></TD>           <TD>LD dst,A   <TD>See Table 5-3 </TR>
<TR> <TD>Load Immediate  <TD>LD dst,n   <TD>See Table 5-3 </TR>
<TR> <TD></TD>           <TD>LD (HL),n  <TD>See Table 5-3 </TR>
<TR> <TD>Load Register (Byte)<TD> LD R,src  <TD>See Table 5-3 </TR>
<TR> <TD></TD>           <TD>LD R,(HL)  <TD>See Table 5-3 </TR>
<TR> <TD></TD>           <TD>LD dst,R   <TD>See Table 5-3 </TR>
<TR> <TD></TD>           <TD>LD (HL),R  <TD>See Table 5-3 </TR>
</TABLE>
<BR><P>

<TABLE BORDER><CAPTION ALIGN=TOP>
Table 5-3. 8-Bit Load Group Allowed Source/Destination Combinations
</CAPTION>
<TR> <TH>Source </TR>
<TR> <TH> Dist. <TH>A <TH>B <TH>C <TH>D <TH>E <TH>H <TH>L
          <TH>IXH <TH>IXL <TH>IYH <TH>IYL <TH>n <TH>(nn)
                    <TH>(BC) <TH>(DE) <TH>(HL) <TH>(IX+d) <TH>(IY+d) </TR>
<TR> <TD>A
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135; <TD>&#135;
                    <TD>&#135;    <TD>&#135;    <TD>&#135;    <TD>&#135;  <TD>&#135;  </TR>
<TR> <TD>B
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD>&#135;    <TD>&#135;  <TD>&#135;  </TR>
<TR> <TD>C
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD>&#135;    <TD>&#135;  <TD>&#135;  </TR>
<TR> <TD>D
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD>&#135;    <TD>&#135;  <TD>&#135;  </TR>
<TR> <TD>E
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135;   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD>&#135;    <TD>&#135;  <TD>&#135;  </TR>
<TR> <TD>H
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD></TD>   <TD></TD>   <TD></TD>   <TD></TD>   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD>&#135;    <TD>&#135;  <TD>&#135;  </TR>
<TR> <TD>L
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD></TD>   <TD></TD>   <TD></TD>   <TD></TD>   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD>&#135;    <TD>&#135;  <TD>&#135;  </TR>
<TR> <TD>IXH
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD>&#135;   <TD>&#135;   <TD></TD>   <TD></TD>   <TD>&#135; </TR>
<TR> <TD>IXL
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD>&#135;   <TD>&#135;   <TD></TD>   <TD></TD>   <TD>&#135; </TR>
<TR> <TD>IYH
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD></TD>   <TD></TD>   <TD>&#135;   <TD>&#135;   <TD>&#135; </TR>
<TR> <TD>IYL
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD></TD>   <TD></TD>   <TD>&#135;   <TD>&#135;   <TD>&#135; </TR>
<TR> <TD>(BC) <TD>&#135;                                          </TR>
<TR> <TD>(DE) <TD>&#135;                                          </TR>
<TR> <TD>(HL)
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD></TD>   <TD></TD>   <TD></TD>   <TD></TD>   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD></TD>    <TD></TD>      <TD></TD>  </TR>
<TR> <TD>(nn) <TD>&#135;
<TR> <TD>(IX+ d)
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD></TD>   <TD></TD>   <TD></TD>   <TD></TD>   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD></TD>    <TD></TD>      <TD></TD>  </TR>
<TR> <TD>(IY+ d)
                <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135; <TD>&#135;
          <TD></TD>   <TD></TD>   <TD></TD>   <TD></TD>   <TD>&#135; <TD></TD>
                    <TD></TD>    <TD></TD>    <TD></TD>    <TD></TD>      <TD></TD>  </TR>
</TABLE>
<STRONG>Note:</STRONG> &#135; are supported combinations.
<BR><P>

<H5><A name="p7"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-7:</A></H5>
<BR><P>

<H4>5.5.2 16-Bit and 32-Bit Load, Exchange, SWAP, and PUSH/POP Group
</H4>
This group of load, exchange, and PUSH/POP instructions
(Table 5-4) allows one or two words of data (two bytes
equal one word) to be transferred between registers and
memory.
<BR><P>

The exchange instructions (Table 5-5) allow for switching
between the primary and alternate register files, exchang-ing
the contents of two register files, exchanging the
contents of an addressing register with the top word on the
stack. For possible combinations of the word exchange
instructions, refer to Table 5-5. The 16-bit and 32-bit loads
include transfer between registers and memory and imme-diate
loads of registers or memory. The Push and Pop
stack instructions are also included in this group. None of
these instructions affect the CPU flags, except for EX AF,AF'.
<BR><P>

Table 5-6 has the supported source/ destination combina-tion
for the 16-bit and 32-bit load instructions. The transfer
size, 16-bit or 32-bit, is determined by the status of LW bit
in SR, or by DDIR Decoder Directives.
<BR><P>

PUSH/ POP instructions are used to save/ restore the con-tents
of a register onto the stack. It can be used to
exchange data between procedures, save the current
register file on context switching, or manipulate data on the
stack, such as return addresses. Supported sources are
listed in Table 5-7.
<BR><P>

Swap instructions allows swapping of the contents of the
Word wide register (BC, DE, HL, IX, or IY) with its Extended
portion. These instructions are useful to manipulate the
upper word of the register to be set in Word mode. For
example, when doing data accesses, other than
00000000H-0000FFFFH address range, use this instruc-tion
to set "data frame" addresses.
<BR><P>

This group of instructions is affected by the status of the LW
bit in SR (Select Register), and Decoder Directives which
specifies the operation mode in Word or Long Word.
<BR><P>

<TABLE BORDER><CAPTION ALIGN=TOP>
Table 5-4. 16-Bit and 32-Bit Load, Exchange, PUSH/POP Group Instructions
</CAPTION>
<TR>
     <TH>Instruction Name  <TH>  Format
          <TH>  Note  </TR>
<TR> <TD>Exchange Word/ Long Word Registers EX dst,src
               <TD> See Table 5-5 </TR>
<TR> <TD>Exchange Byte/ Word Registers with Alternate Bank <TD>EXX  </TR>
<TR> <TD>Exchange Register Pair with Alternate Bank <TD> EX RR,RR'
               <TD> RR = AF, BC, DE, or HL  </TR>
<TR> <TD>Exchange Index Register with Alternate Bank <TD>EXXX  </TR>
<TR> <TD> </TD><TD> EXXY </TR>
<TR> <TD>Exchange All Registers with Alternate Bank <TD>EXALL </TR>
<TR> <TD>Load Word/ Long Word Registers <TD>LD dst,src
               <TD>See Table 5-6 </TR>
<TR> <TD> </TD> <TD>LDW dst,src <TD>
                    See Table 5-6 </TR>
<TR> <TD>POP   <TD> POP dst   <TD>See Table 5-7 </TR>
<TR> <TD>PUSH  <TD> PUSH src  <TD>See Table 5-7 </TR>
<TR> <TD>Swap Contents of D31-D16 and D15-D0 <TD>SWAP dst
                    <TD>dst = BC, DE, HL, IX, or IY </TR>
</TABLE>


<TABLE BORDER><CAPTION ALIGN=TOP>
Table 5-5. Supported Source and Destination
Combination for 16-Bit and 32-Bit
Exchange Instructions
</CAPTION>
<TR>
     <TH> </TH> <TH>  Source  </TD></TR>

<TR> <TD> <TABLE BORDER>
          <TR> <TH> Destination</TH></TR>
          <TR> <TD> BC   </TD></TR>
          <TR> <TD> DE   </TD></TR>
          <TR> <TD> HL   </TD></TR>
          <TR> <TD> IX   </TD></TR>
          <TR> <TD> (SP) </TD></TR>
          </TABLE>
                <TD> <TABLE BORDER>
                     <TR> <TH> BC</TH> <TH> DE</TH> <TH> HL </TH>    <TH> IX </TH>    <TH> IY </TH> </TR>
                     <TR> <TD>&#164;</TD> <TD>&#164;</TD> <TD> &#164</TD><TD> &#164</TD></TR>
                     <TR> <TD></TD>   <TD>&#164;</TD><TD> &#164;</TD><TD> &#164;</TD> </TR>
                     <TR> <TD></TD>   <TD></TD>   <TD> &#164;</TD><TD> &#164;</TD> </TR>
                     <TR> <TD></TD>   <TD></TD>   <TD></TD>   <TD> &#164;</TD> </TR>
                     <TR> <TD></TD>   <TD> &#164;</TD><TD> &#164;</TD><TD> &#164;</TD> </TR>
                     </TABLE> </TD>
</TABLE>
Note: &quot; &#164 &quot; are supported combinations. The exchange
instructions which designate IY register as destination are
covered by the other combinations. These Exchange
Word instructions are affected by Long Word mode.
<BR><P>

<H5><A name="p8"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-8:</A></H5>
<BR><P>

<H4>5.5.2 16-Bit and 32-Bit Load, Exchange, SWAP and PUSH/POP Group (Continued)
</H4>
<BR><P>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-6. Supported Source and Destination Combination
for 16-Bit and 32-Bit Load Instructions.</CAPTION>
<TR> <TD></TD> <TH>Source</TR>
<TR><TH>Destination</TH>
    <TH>BC <TH>DE <TH>HL <TH>IX <TH>IY <TH>SP <TH>nn <TH>(nn) <TH>(BC)
         <TH>(DE) <TH>(HL) <TH>(IX+d) <TH>(IY+d) <TH>(SP+d) </TR>
<TR> <TD>BC <TD>L <TD>L <TD>L <TD>L <TD>L <TD></TD> <TD>IL <TD>IL <TD>L <TD>L <TD>L <TD>IL <TD>IL <TD>IL </TR>
<TR> <TD>DE <TD>L <TD>L <TD>L <TD>L <TD>L <TD></TD> <TD>IL <TD>IL <TD>L <TD>L <TD>L <TD>IL <TD>IL <TD>IL </TR>
<TR> <TD>HL <TD>L <TD>L <TD>L <TD>L <TD>L <TD></TD> <TD>IL <TD>IL <TD>L <TD>L <TD>L <TD>IL <TD>IL <TD>IL </TR>
<TR> <TD>IX <TD>L <TD>L <TD>L <TD></TD> <TD>L <TD></TD> <TD>IL <TD>IL <TD>L <TD>L <TD>L <TD></TD> <TD>IL <TD>IL </TR>
<TR> <TD>IY <TD>L <TD>L <TD>L <TD>L <TD></TD> <TD></TD> <TD>IL <TD>IL <TD>L <TD>L <TD>L <TD>IL <TD></TD> <TD>IL </TR>
<TR> <TD>SP <TD></TD> <TD></TD> <TD>L <TD>L <TD>L <TD></TD> <TD>IL <TD>IL </TR>
<TR> <TD>(BC) <TD>L <TD>L <TD>L <TD>L <TD>L <TD></TD> <TD>ILW </TR>
<TR> <TD>(DE) <TD>L <TD>L <TD>L <TD>L <TD>L <TD></TD> <TD>ILW </TR>
<TR> <TD>(HL) <TD>L <TD>L <TD>L <TD>L <TD>L <TD></TD> <TD>ILW </TR>
<TR> <TD>(nn) <TD>IL <TD>IL <TD>IL <TD>IL <TD>IL <TD>IL </TR>
<TR> <TD>(IX+d) <TD>IL <TD>IL <TD>IL <TD></TD> <TD>IL </TR>
<TR> <TD>(IY+d) <TD>IL <TD>IL <TD>IL <TD>IL </TR>
<TR> <TD>(SP+d) <TD>IL <TD>IL <TD>IL <TD>IL <TD>IL </TR>
</TABLE>
Note: The column with the character( s) are the allowed source/ destination combinations. The combination with
"L" means that the instruction is affected by Long Word
mode, "I" means that the instruction is can be used with
DDIR Immediate instruction. Also, "W" means the instruction
uses the mnemonic of "LDW" instead of "LD".
<BR><P>
<BR><P>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-7. Supported Operand for PUSH/POP Instructions</CAPTION>
<TR><TD></TD> <TH>AF <TH>BC <TH>DE <TH>HL <TH>IX <TH>IY <TH>SR <TH>nn </TR>
<TR><TD>PUSH <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> </TR>
<TR><TD>POP  <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> <TD> &#164;</TD> </TR>
</TABLE>
<STRONG>Note:</STRONG> These PUSH/POP instructions are affected by Long Word mode of operations.
<BR><P>
<BR><P>

Various Z380 CPU registers are dedicated to specific
functions for these instructions -- the BC register for a
counter, the DEz/DE and HLz/HL registers for memory
pointers, and the accumulator for holding the byte value
being sought. The repetitive forms of these instructions are
interruptible; this is essential since the repetition count can
be as high as 65536. The instruction can be interrupted
after any interaction, in which case the address of the
instruction itself, rather than next one, is saved on the
stack. The contents of the operand pointer registers, as
well as the repetition counter, are such that the instruction
can simply be reissued after returning from the interrupt
without any visible difference in the instruction execution.
<BR><P>

In case of Word or Long Word block transfer instructions,
the counter value held in the BC register is decremented
by two or four, depending on the LW bit status. Since
exiting from these instructions will be done when counter
value gets to 0, the count value stored in the BC registers
<BR><P>

<H4>5.5.3 Block Transfer and Search Group
</H4>
This group of instructions (Table 5-8) supports block
transfer and string search functions. Using these instruc-tions,
a block of up to 65536 bytes of byte, Word, or Long
Word data can be moved in memory, or a byte string can
be searched until a given value is found. All the operations
can proceed through the data in either direction. Further-more,
the operations can be repeated automatically while
decrementing a length counter until it reaches zero, or they
can operate on one storage unit per execution with the
length counter decremented by one and the source and
destination pointer register properly adjusted. The latter
form is useful for implementing more complex operations
in software by adding other instructions within a loop
containing the block instructions.
<BR><P>

<H5><A name="p9"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-9:</A></H5>
<BR><P>

has to be an even number (D0 = 0) in Word mode transfer,
and a multiple of four in Long Word mode (D1 and D0 are
both 0). Also, in Word or Long Word Block transfer,
memory pointer values are recommended to be even
numbers so the number of the transactions will be mini-mized.
<BR><P>

Note that regardless of the Z380's operation mode, Native
or Extended, memory pointer increment/ decrement will be
done in modulo 2 32 . For example, if the operation is LDI and
HL31-HL0 (HLz and HL) hold 0000FFFF, after the opera-tion
the value in the HL31-HL0 will be 0010000.
<BR><P>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-8. Block Transfer and Search Group
</CAPTION>
<TR><TH>Instruction Name <TH>Format </TR>
<TR><TD>Compare and Decrement <TD>CPD </TR>
<TR><TD>Compare, Decrement and Repeat <TD>CPDR </TR>
<TR><TD>Compare and Increment <TD>CPI </TR>
<TR><TD>Compare, Increment and Repeat <TD>CPIR </TR>
<TR><TD>Load and Decrement <TD>LDD </TR>
<TR><TD>Load, Decrement and Repeat <TD>LDDI </TR>
<TR><TD>Load and Increment <TD>LDI </TR>
<TR><TD>Load, Increment and Repeat <TD>LDIR </TR>
<TR><TD>Load and Decrement in Word/Long Word <TD>LDDW </TR>
<TR><TD>Load, Decrement and Repeat in Word/Long Word <TD>LDDRW </TR>
<TR><TD>Load and Increment in Word/Long Word <TD>LDIW </TR>
<TR><TD>Load, Increment and Repeat in Word/Long Word <TD>LDIRW </TR>
</TABLE>
<BR><P>
<BR><P>

<H4>5.5.4 8-bit Arithmetic and Logical Group
</H4>
This group of instructions (Table 5-9) perform 8-bit arith-metic
and logical operations. The Add, Add with Carry,
Subtract, Subtract with Carry, AND, OR, Exclusive OR, and
Compare takes one input operand from the accumulator
and the other from a register, from immediate data in the
instruction itself, or from memory. For memory addressing
modes, follows are supported— Indirect Register, Indexed,
and Direct Address— except multiplies, which returns the
16-bit result to the same register by multiplying the upper
and lower bytes of one of the register pair (BC, DE, HL, or SP).
<BR><P>

The Increment and Decrement instructions operate on
data in a register or in memory; all memory addressing
modes are supported. These instructions operate only on
the accumulator— Decimal Adjust, Complement, and Ne-gate.
The final instruction in this group, Extend Sign, sets
the CPU flags according to the computed result.
<BR><P>

The EXTS instruction extends the sign bit and leaves the
result in the HL register. If it is in Long Word mode, HLz
(HL31-HL16) portion is also affected.
<BR><P>

The TST instruction is a nondestructive AND instruction. It
ANDs "A" register and source, and changes flags accord-ing
to the result of operation. Both source and destination
values will be preserved.
<BR><P>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-9. Supported Source/Destination for 8-Bit Arithmetic and Logic Group
</CAPTION>

<TR><TH>Instruction Name <TH>Format <TH>src/dst <TH>A <TH>B <TH>C <TH>D <TH>E <TH>H <TH>L <TH>IXH <TH>IXL <TH>IYH <TH>IYL <TH>n <TH>(HL) <TH>(IX+d) <TH>(IY+x) </TR>

<TR><TD>Add With Carry (Byte) <TD>ADC A, src <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD>Add (Byte) <TD>ADD A,src <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD>AND <TD>AND [A,]src <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD>Compare (Byte) <TD>CP [A,]src <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD></TD></TR>

<TR><TD>Complement Accumulator <TD>CPL [A] <TD>dst <TD> &#164; </TR>
<TR><TD>Decimal Adjust Accumulator <TD>DAA <TD>dst <TD> &#164; </TR>
<TR><TD>Decrement (Byte) <TD>DEC dst <TD>dst <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD>Extend Sign (Byte) <TD>EXTS [A] <TD>dst <TD> &#164; </TR>
<TR><TD></TD></TR>

<TR><TD>Increment (Byte) <TD>INC dst <TD>dst <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD>Multiply (Byte) <TD>MLT src  <TD>Note 1  </TR>
<TR><TD>Negate Accumulator <TD>NEG [A] <TD>dst <TD> &#164; </TR>
<TR><TD>OR <TD>OR [A,]src <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD></TD></TR>

<TR><TD>Subtract with Carry (Byte) <TD>SBC A, src <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD>Subtract (Byte) <TD>SUB [A,]src <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
<TR><TD>Nondestructive Test <TD>TST dst <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD></TD><TD></TD><TD></TD><TD></TD><TD> &#164;<TD> &#164; </TR>
<TR><TD>Exclusive OR <TD>XOR [A,]src <TD>src <TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164;<TD> &#164; </TR>
</TABLE>

<STRONG>Note 1:</STRONG> dst = BC, DE, HL, or SP.
<BR><P>
<BR><P>

<H5><A name="p10"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-10:</A></H5>
<BR><P>

<H4>5.5.5 16-Bit Arithmetic Operation
</H4>
This group of instructions (Table 5-10) provide 16-bit
arithmetic instructions. The Add, Add with Carry, Subtract,
Subtract with Carry, AND, OR, Exclusive OR, and Com-pare
takes one input operand from an addressing register
and the other from a 16-bit register, or from the instruction
itself; the result is returned to the addressing register. The
16-bit Increment and Decrement instructions operate on
data found in a register or in memory; the Indirect Register
or Direct Address addressing mode can be used to
specify the memory operand.
<BR><P>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-10. 16-Bit Arithmetic Operation
</CAPTION>
<TR><TH>Instruction Name<TH>Format<TH>src/dst<TH>BC<TH>DE<TH>HL<TH>SP<TH>IX<TH>IY<TH>nn<TH>(nn)<TH>(IX+d)<TH>(IY+d)<TD></TD></TR>

<TR><TD>Add With Carry (Word) <TD>ADC HL,src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164; </TR>
<TR><TD><TD>ADCW [HL],src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Add (Word) <TD>ADD HL,src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD></TD><TD></TD><TD>&#164;<TD></TD><TD></TD><TD>X </TR> </TR>

<TR><TD><TD>ADD IX,src <TD>src <TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD>X </TR>
<TR><TD><TD>ADD IY,src <TD>src <TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD></TD><TD>&#164;<TD></TD><TD></TD><TD></TD><TD></TD><TD>X </TR>
<TR><TD><TD>ADDW [HL,] src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Add to Stack Pointer <TD>ADD SP,nn <TD>src <TD></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD>&#164;<TD></TD><TD></TD><TD></TD><TD>X </TR>
<TR><TD>AND Word <TD>ANDW [HL,]src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Complement Accumulator <TD>CPLW [HL] <TD>dst <TD></TD><TD></TD><TD>&#164; </TR>
<TR><TD>Compare (Word) <TD>CPW [HL,]src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Decrement (Word) <TD>DEC[W] dst <TD>dst <TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD></TD><TD></TD><TD></TD><TD>X </TR>
<TR><TD>Divide Unsigned <TD>DIVUW [HL,]src
<TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Extend Sign (Word) <TD>EXTSW [HL] <TD>dst <TD></TD><TD></TD><TD>&#164; </TR>
<TR><TD>Increment (Word) <TD>INC[W] dst <TD>dst <TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD></TD><TD></TD><TD></TD><TD>X </TR>
<TR><TD>Multiply Word Signed <TD>MULT [HL,]src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Multiply Word Unsigned <TD>MULTUW [HL,]src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Negate Accumulator <TD>NEGW [A] <TD>dst <TD></TD><TD></TD><TD>&#164; </TR>
<TR><TD>OR Word <TD>ORW [HL,]src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Subtract with Carry (Word) <TD>SBC HL,src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD></TD><TD></TD><TD>&#164; </TR>
<TR><TD><TD>SBCW [HL,]src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Subtract (Word) <TD>SUB HL,( nn) <TD>src <TD></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD>&#164;<TD></TD><TD></TD><TD>X </TR>
<TR><TD><TD>SUBW [HL,]src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>
<TR><TD>Subtract from Stack Pointer <TD>SUB SP,nn <TD>src <TD></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD>&#164;<TD></TD><TD></TD><TD></TD><TD>X </TR>
<TR><TD>Exclusive OR <TD>XORW [HL,]src <TD>src <TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164;<TD>&#164;<TD></TD><TD>&#164;<TD>&#164; </TR>

</TABLE>
Note: that the instructions with "X" at the rightmost column is affected by
Extended mode. These operate across all the 32 bits in Modulo 2 32 for
address calculation.
<BR><P>
<BR><P>

The remaining 16-bit instructions provide general arithmetic
capability using the HL register as one of the input
operands. The word Add, Subtract, Compare, and signed
and unsigned Multiply instructions take one input operand
from the HL register and the other from a 16-bit register,
from the instruction itself, or from memory using Indexed

or Direct Address addressing mode. The 32-bit result of a
multiply is returned to the HLz and HL (HL31-HL0). The
unsigned divide instruction takes a 16-bit dividend from
the HL register and a 16-bit divisor from a register, from the
instruction, or memory using the Indexed mode. The 16-bit
quotient is returned in the HL register and the 16-bit
reminder is returned to the HLz (HL31..HL16). The Extend
Sign instruction takes the contents of the HL register and
delivers the 32-bit result to the HLz and HL registers. The
Negate HL instruction negates the contents of the HL
register.
<BR><P>

Except for Increment, Decrement, and Extend Sign, all the
instructions in this group set the CPU flags to reflect the
computed result.
<BR><P>

<H5><A name="p11"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-11:</A></H5>
<BR><P>

<H4>5.5.6 8-Bit Manipulation, Rotate and Shift Group
</H4>
Instructions in this group (Table 5-11) test, set, and reset
bits within bytes, and rotate and shift byte data one bit
position. Bits to be manipulated are specified by a field
within the instruction. Rotate can optionally concatenate
the Carry flag to the byte to be manipulated. Both left and
right shifting is supported. Right shifts can either shift 0 into
bit 7 (logical shifts), or can replicate the sign in bits 6 and
7 (arithmetic shifts). All these instructions, Set Bit and
Reset Bit, set the CPU flags according to the calculated
result; the operand can be a register or a memory location
specified by the Indirect Register or Indexed addressing
mode.
<BR><P>

The RLD and RRD instructions are provided for manipulat-ing
strings of BCD digits; these rotate 4-bit quantities in
memory specified by the Indirect Register. The low-order
four bits of the accumulator are used as a link between
rotation of successive bytes.
<BR><P>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-11. Bit Set/Reset/Test, Rotate and Shift Group
</CAPTION>
<TH>Instruction Name <TH>Format <TH>A <TH>B <TH>C <TH>D <TH>E <TH>H <TH>L <TH>(HL) <TH>(IX+d) <TH>(IY+d) </TR>

<TR><TD>Bit Test <TD>BIT dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Reset Bit <TD>RES dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Rotate Left <TD>RL dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Rotate Left Accumulator <TD>RLA <TD>&#164;  </TR>


<TR><TD>Rotate Left Circular <TD>RLC dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Rotate Left Circular (Accumulator) <TD>RLCA <TD>&#164;  </TR>
<TR><TD>Rotate Left Digit <TD>RLD <TD>&#164;  </TR>
<TR><TD>Rotate Right <TD>RR dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>


<TR><TD>Rotate Right Accumulator <TD>RRA <TD>&#164;  </TR>
<TR><TD>Rotate Right Circular <TD>RRC dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Rotate Right Circular (Accumulator) <TD>RRCA <TD>&#164;  </TR>
<TR><TD>Rotate Right Digit <TD>RRD <TD>&#164;  </TR>


<TR><TD>Set Bit <TD>SET dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Shift Left Arithmetic <TD>SLA dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Shift Right Arithmetic <TD>SRA dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Shift Right Logical <TD>SRL <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
</TABLE>
<BR><P>
<BR><P>

5.5.7 16-Bit Manipulation, Rotate and Shift Group
Instructions in this group (Table 5-12) rotate and shift word
data one bit position. Rotate can optionally concatenate
the Carry flag to the word to be manipulated. Both left and
right shifting is supported. Right shifts can either shift 0 into
bit 15 (logical shifts), or can replicate the sign in bits 14 and
15 (arithmetic shifts). The operand can be a register pair or
memory location specified by the Indirect Register or
Indexed addressing mode, as shown below.
<BR><P>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-12. 16-Bit Rotate and Shift Group.
</CAPTION>
Destination
<TR><TH>Instruction Name <TH>Format <TH>BC <TH>DE <TH>HL <TH>IX <TH>IY <TH>(HL) <TH>(HL) <TH>(IX+d) <TH>(IY+d) </TR>

<TR><TD>Rotate Left Word <TD>RLW dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Rotate Left Circular Word <TD>RLCW dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Rotate Right Word <TD>RRW dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Rotate Right Circular Word <TD>RRCW dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Shift Left Arithmetic Word <TD>SLAW dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Shift Right Arithmetic Word <TD>SRAW dst <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
<TR><TD>Shift Right Logical Word <TD>SRLW <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164; <TD>&#164;  </TR>
</TABLE>
<BR><P>
<BR><P>

<H5><A name="p12"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-12:</A></H5>
<BR><P>

<H4>5.5.8 Program Control Group
</H4>
This group of instructions (Table 5-13) affect the Program
Counter (PC) and thereby control program flow. The CPU
registers and memory are not altered except for the Stack
Pointer and the Stack, which play a significant role in
procedures and interrupts. (An exception is Decrement
and Jump if Non-Zero [DJNZ], which uses a register as a
loop counter.) The flags are also preserved except for the
two instructions specifically designed to set and comple-ment
the Carry flag.
<BR><P>

The Set/ Reset Condition flag instructions can be used with
Conditional Jump, conditional Jump Relative, Conditional
Call, and Conditional Return instructions to control the
program flow.
<BR><P>

The Jump and Jump Relative (JR) instructions provide a
conditional transfer of control to a new location if the
processor flags satisfy the condition specified in the instruction.
Jump Relative, with an 8-bit offset (JR e), is a two
byte instruction that jumps any instructions within the
range -126 to +129 bytes from the location of this instruction.
Most conditional jumps in programs are made to
locations only a few bytes away; the Jump Relative, with an
8-bit offset, exploits this fact to improve code compact-ness
and efficiency. Jump Relative, with a 16-bit offset (JR
[cc,] ee), is a four byte instruction that jumps any instruc-tions
within the range -32765 to +32770 bytes from the
location of this instruction, and Jump Relative, with a 24-bit
offset (JR [cc,] eee), is a five byte instruction that jumps any
instructions within the range –8388604 to +8388611 bytes
from the location of this instruction. By using these Jump
Relative instructions with 16-bit or 24-bit offsets allows to
write relocatable (or location independent) programs.
<BR><P>


<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-13. Program Control Group Instructions
</CAPTION>

<TR><TH>Instruction Name <TH>Format <TH>nn <TH>(PC+d) <TH>(HL) <TH>(IX) <TH>(IY)
<TR><TD>Call <TD>CALL cc,dst <TD>&#164; </TR>
<TR><TD>Complement Carry Flag <TD>CCF </TR>
<TR><TD>Call Relative <TD>CALR cc,dst <TD></TD><TD>&#164; </TR>
<TR><TD>Decrement and Jump if Non-zero <TD>DJNZ dst <TD></TD><TD>&#164; </TR>
<TR><TD></TD></TR>
<TR><TD>Jump <TD>JP cc,dst <TD>&#164; </TR>
<TR><TD></TD>   <TD>JP dst <TD></TD><TD></TD><TD>&#164;<TD>&#164;<TD>&#164; </TR>
<TR><TD>Jump Relative <TD>JR cc,dst <TD></TD><TD>&#164; </TR>
<TR><TD>Return <TD>RET cc </TR>
<TR><TD>Restart <TD>RST p <TD>&#164; </TR>
<TR><TD>Set Carry Flag <TD>SCF </TR>
</TABLE>
<BR><P>
<BR><P>

Call and Restart are used for calling subroutines; the
current contents of the PC are pushed onto the stack and
the effective address indicated by the instruction is loaded
into the PC. The use of a procedure address stack in this
manner allows straightforward implementation of nested
and recursive procedures. Call, Jump, and Jump Relative
can be unconditional or based on the setting of a CPU flag.
<BR><P>

Call Relative (CALR) instructions work just like ordinary
Call instructions, but with Relative address. An 8-bit, 16-
bit, or 24-bit offset value can be used, and that allows to call
procedure within the range of -126 to +129 bytes (8-bit
offset; CALR [cc,] e), -32765 to +32770 bytes (16-bit offset;
CALR [cc,] ee), or -8388604 to +8388611 bytes (JR [cc,]
eee) are supported. These instructions are really useful to
write relocatable (position-independant) programs.
<BR><P>

Jump is available with Indirect Register mode in addition
to Direct Address mode. It can be useful for implementing
complex control structures such as dispatch tables. When
using Direct Address mode for a Jump or Call, the operand
is used as an immediate value that is loaded into the PC to
specify the address of the next instruction to be executed.
<BR><P>

The conditional Return instruction is a companion to the
call instruction; if the condition specified in the instruction
is satisfied, it loads the PC from the stack and pops the
stack.
<BR><P>

A special instruction, Decrement and Jump if Non-Zero
(DJNZ), implements the control part of the basic Pascal
FOR loop which can be implemented in an instruction. It
supports 8-bit, 16-bit, and 24-bit displacement.
<BR><P>

Note that Jump Relative, Call Relative, and DJNZ instructions
use modulo 2<SUP>16</SUP> in Native mode, and 2<SUP>32</SUP> in Extended
mode for address calculation. So it is possible that the
Z380 CPU can jump to an unexpected address.
<BR><P>

<H5><A name="p13"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-13:</A></H5>
<BR><P>

<H4>5.5.9 External Input/ Output Instruction Group
</H4>

This group of instructions (Table 5-14) are used for trans-ferring
a byte, a word, or string of bytes or words between
peripheral devices and the CPU registers or memory. Byte
I/O port addresses transfer bytes on D7..D0 only. These 8-bit
peripherals in a 16-bit data bus environment must be
connected to data line D7..D0. In an 8-bit data bus environment,
word I/O instructions to external I/O peripherals
should not be used; however, on-chip peripherals which is
external to the CPU core and assigned as word I/O device
can still be accessed by word I/O instructions.
<BR><P>

The instructions for transferring a single byte (IN, OUT) can
transfer data between any 8-bit CPU register or memory
address specified in the instruction and the peripheral port
specified by the contents of the C register. The IN instruction
sets the CPU flags according to the input data;
however, special instructions restricted to using the CPU
accumulator and Direct Address mode and do not affect
the CPU flags. Another variant tests an input port specified
by the contents of the C register and sets the CPU flags
without modifying CPU registers or memory.
<BR><P>

The instructions for transferring a single word (INW, OUTW)
can transfer data between the register pair and the peripheral
port specified by the contents of the C register. For
Word I/O, the contents of B, D, or H appear on D7..D0 and
the contents of C, E, or L appear D15..D7. These instructions
do not affect the CPU flags.
<BR><P>

Also, there are I/O instructions available which allow to
specify 16-bit absolute I/O address (with DDIR decoder
directives, a 24-bit or 32-bit address is specified) is avail-able.
These instructions do not affect the CPU flags.
<BR><P>

The remaining instructions in this group form a powerful
and complete complement of instructions for transferring
blocks of data between I/O ports and memory. The opera-tion
of these instructions is very similar to that of the block
move instructions described earlier, with the exception
that one operand is always an I/O port whose address
remains unchanged while the address of the other oper-and
(a memory location) is incremented or decremented. In
Word mode of transfer, the counter (i. e., BC register) holds
the number of transfers, rather than number of bytes to
transfer in memory-to-memory word block transfer. Both
byte and word forms of these instructions are available.
The automatically repeating forms of these instructions are
interruptible, like memory-to-memory transfer.
<BR><P>

The I/O addresses output on the address bus is de-pendant
on the I/O instruction, as listed in Table 2-1.
<BR><P>

<H5><A name="p14"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-14:</A></H5>
<BR><P>

<H4>5.5.9 External Input/ Output Instruction Group (Continued)
</H4>
<P><BR>


<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-14. External I/O Group Instructions.
</CAPTION>
<TR><TH>Instruction Name <TH>Format<TH></TH></TR>
<TR><TD>Input <TD>IN dst,(C) <TD>dst= A, B, C, D, E, H or L </TR>
<TR><TD>Input Accumulator <TD>IN A,(n) </TR>
<TR><TD>Input to Word-Wide Register <TD>INW <TD>dst,(C) dst= BC, DE or HL </TR>
<TR><TD>Input Byte from Absolute Address <TD>INAW A,(nn) </TR>

<TR><TD>Input Word from Absolute Address <TD>INAW HL,(nn) </TR>
<TR><TD>Input and Decrement (Byte) <TD>IND </TR>
<TR><TD>Input and Decrement (Word) <TD>INDW </TR>
<TR><TD>Input, Decrement, and Repeat (Byte) <TD>INDR </TR>

<TR><TD>Input, Decrement, and Repeat (Word) <TD>INDRW </TR>
<TR><TD>Input and Increment (Byte) <TD>INI </TR>
<TR><TD>Input and Increment (Word) <TD>INIW </TR>
<TR><TD>Input, Increment, and Repeat (Byte) <TD>INIR </TR>

<TR><TD>Input, Increment, and Repeat (Word) <TD>INIRW </TR>
<TR><TD>Output <TD>OUT (C),src <TD>src = A, B, C, D, E, H, L, or n </TR>
<TR><TD>Output Accumulator <TD>OUT (n),A </TR>
<TR><TD>Output from Word-Wide Register <TD>OUTW (C),src <TD>src = BC, DE, HL, or nn </TR>

<TR><TD>Output Byte from Absolute Address <TD>OUTAW (nn),A </TR>
<TR><TD>Output Word from Absolute Address <TD>OUTAW (nn),HL </TR>
<TR><TD>Output and Decrement (Byte) <TD>OUTD </TR>
<TR><TD>Output and Decrement (Word) <TD>OUTDW </TR>

<TR><TD>Output, Decrement, and Repeat (Byte) <TD>OTDR </TR>
<TR><TD>Output, Decrement, and Repeat (Word) <TD>OTDRW </TR>
<TR><TD>Output and Increment (Byte) <TD>OUTI </TR>
<TR><TD>Output and Increment (Word) <TD>OTIW </TR>
<TR><TD>Output, Increment, and Repeat (Byte) <TD>OTIR </TR>
<TR><TD>Output, Increment, and Repeat (Word) <TD>OTIRW </TR>
</TABLE>
<BR><P>
<BR><P>

<H5><A name="p15"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-15:</A></H5>
<BR><P>

<H4>5.5.10 Internal I/O Instruction Group
</H4>
<P><BR>

This group (Table 5-15) of instructions is used to access
on-chip I/O addressing space on the Z380 CPU. This
group consists of instructions for transferring a byte from/to
Internal I/O locations and the CPU registers or memory,
or a blocks of bytes from the memory to the same size of
Internal I/O locations for initialization purposes. These
instructions are originally assigned as newly added I/O
instructions on the Z180 MPU to access Page 0 I/O
addressing space. There is 256 Internal I/O locations, and
all of them are byte-wide. When one of these I/O instructions
is executed, the Z380 MPU outputs the register
address being accessed in a pseudo transaction of two
BUSCLK durations cycle, with the address signals A31-A8
at 0. In the pseudo transactions, all bus control signals are
at their inactive state.
<P><BR>

The instructions for transferring a single byte (IN0, OUT0)
can transfer data between any 8-bit CPU register and the
Internal I/O address specified in the instruction. The IN0
instruction sets the CPU flags according to the input data;
however, special instructions which do not have a destination
in the instruction with Direct Address (IN0 (n)), do not
affect the CPU register, but alters flags accordingly. An-other
variant, the TSTIO instruction, does a logical AND to
the instruction operand with the internal I/O location specified
by the C register and changes the CPU flags without
modifying CPU registers or memory.
<P><BR>

The remaining instructions in this group form a powerful
and complete complement of instructions for transferring
blocks of data from memory to Internal I/O locations. The
operation of these instructions is very similar to that of the
block move instructions described earlier, with the excep-tion
that one operand is always an Internal I/O location
whose address also increments or decrements by one
automatically, Also, the address of the other operand (a
memory location) is incremented or decremented. Since
Internal I/O space is byte-wide, only byte forms of these
instructions are available. Automatically repeating forms
of these instructions are interruptible, like memory-to-memory
transfer.
<P><BR>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-15. Internal I/O Instruction Group
</CAPTION>
<TR><TH>Instruction Name <TH>Format<TH></TH></TR>
<TR><TD>Input from Internal I/O Location <TD>IN0 dst,(n) <TD>dst= A, B, C, D, E, H or L </TR>
<TR><TD>Input from Internal I/O Location (Nondestructive) <TD>IN0 (n) </TR>
<TR><TD>Test I/O <TD>TSTIO n </TR>
<TR><TD>Output to Internal I/O Location <TD>OUT0 (n),src <TD>src= A, B, C, D, E, H or L </TR>
<TR><TD>Output to Internal I/O and Decrement <TD>OTDM </TR>
<TR><TD>Output to Internal I/O and Increment <TD>OTIM </TR>
<TR><TD>Output to Internal I/O, Decrement and Repeat <TD>OTDMR </TR>
<TR><TD>Output to Internal I/O, Increment and Repeat <TD>OTIMR </TR>
</TABLE>
<BR><BR>
Currently, the Z380 CPU core has the following registers as a part of the CPU core:
<BR><BR>

<TABLE BORDER>
<TR><TH>Register Name <TH>Internal I/O address</TR>
<TR><TD>Interrupt Enable Register <TD>16H</TR>
<TR><TD>Assigned Vector Base Register <TD>17H</TR>
<TR><TD>Trap Register <TD>18H</TR>
<TR><TD>Chip Version ID Register <TD>0FFH</TR>
</TABLE>
<P><BR>
<P><BR>

Chip Version ID register returns one byte data, which
indicates the version of the CPU, or the specific implemen-tation
of the Z380 CPU based Superintegration device.
Currently, the value 00H is assigned to the Z380 MPU, and
other values are reserved.
<P><BR>


For the other three registers, refer to Chapter 6, "Interrupt
and Trap."
<P><BR>


Also, the Z380 MPU has registers to control chip selects,
refresh, waits, and I/O clock divide to Internal I/O address
00H to 10H. For these register, refer to Z380 MPU Product
specification.
<P><BR>

<H5><A name="p16"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-16:</A></H5>
<BR><P>

<H4>5.5.11 CPU Control Group
</H4>
<P><BR>
The instructions in this group (Table 5-16) act upon the
CPU control and status registers or perform other functions
that do not fit into any of the other instruction groups. These
include two instructions used for returning from an inter-rupt
service routine. Return from Nonmaskable Interrupt
(RETN) and Return from Interrupt (RETI) are used to pop
the Program Counter from the stack and manipulate the
Interrupt Enable Flag (IEF1 and IEF2), or to signal a reset
to the Z80 peripherals family.
<P><BR>


The Disable and Enable Interrupt instructions are used to
set/reset interrupt mask. Without a mask parameters, it
disables/enables maskable interrupt globally. With mask
data, it enables/disables interrupts selectively.
<P><BR>


HALT and SLEEP instructions stop the CPU and waits for
an event to happen, or puts the system into the power save
mode.
<P><BR>


Bank Test instructions reports which register file, primary
or alternate bank, is in use at the time, and reflect the status
into a flag register. For example, this instruction is useful to
implement the recursive program, which uses the alter-nate
bank to save a register for the first time, and saves
registers into memory thereafter.
<P><BR>

Mode Test instructions reports the current mode of opera-tion,
Native/ Extended, Word/ Long Word, Locked or not.
This instruction can be used to switch procedures de-pending
on the mode of operation.
<P><BR>

Load Accumulator from R or I Register instructions are
used to report current interrupt mask status. Load from/to
register instructions are used to initialize the I register.
<P><BR>

Load Control register instructions are used to read/write
the Status Register, set/reset control bit instructions and to
set/reset the control bits in the SR.
<P><BR>

The No Operation instruction does nothing, and can be
used as a filler, for debugging purposes, or for timing
adjustment.
<P><BR>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-16. CPU Control Group
</CAPTION>
<TR><TH>Instruction Name <TH>Format </TR>
<TR><TD>Bank Test <TD>BTEST </TR>
<TR><TD>Disable Interrupt <TD>DI [mask] </TR>
<TR><TD>Enable Interrupt <TD>EI [mask] </TR>
<TR><TD>HALT <TD>HALT </TR>
<TR><TD>Interrupt Mode Select <TD>IM p </TR>
<TR><TD>Load Accumulator from I or R Register <TD>LD A,src </TR>
<TR><TD>Load I or R Register from Accumulator <TD>LD dst,A </TR>
<TR><TD>Load I Register from HL Register <TD>LD[W] HL,I </TR>
<TR><TD>Load HL Register from I Register <TD>LD[W] HL,I </TR>
<TR><TD>Load Control <TD>LDCTL dst,src </TR>
<TR><TD>Mode Test <TD>MTEST </TR>
<TR><TD>No Operation <TD>NOP </TR>
<TR><TD>Return from Interrupt <TD>RETI </TR>
<TR><TD>Return from Nonmaskable Interrupt <TD>RETN </TR>
<TR><TD>Reset Control Bit <TD>RESC dst <TD>dst= LCK, LW </TR>
<TR><TD>Set Control Bit <TD>SETC dst <TD>dst= LCK, LW, XM </TR>
<TR><TD>Sleep <TD>SLP </TR>
</TABLE>
<P><BR>
<P><BR>

<H5><A name="p17"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-17:</A></H5>
<BR><P>

<H4>5.5.12 Decoder Directives
</H4>

The Decoder Directives (Table 5-17) are a special instruc-tions
to expand the Z80 instruction set to handle the Z380's
4 Gbytes of linear memory addressing space. For details
on this instruction, refer to Chapter 3.
<P><BR>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-17. Decoder Directive Instructions
</CAPTION>
<TR><TD>DDIR W <TD>Word Mode </TR>
<TR><TD>DDIR IB,W <TD>Immediate Byte, Word Mode </TR>
<TR><TD>DDIR IW,W <TD>Immediate Word, Word Mode </TR>
<TR><TD>DDIR IB <TD>Immediate Byte </TR>
<TR><TD>DDIR LW <TD>Long Word Mode </TR>
<TR><TD>DDIR IB,LW <TD>Immediate Byte, Long Word Mode </TR>
<TR><TD>DDIR IW,LW <TD>Immediate Word, Long Word Mode </TR>
<TR><TD>DDIR IW <TD>Immediate Word </TR>
</TABLE>
<P><BR>

<BR><P>
<H3>5.6 NOTATION AND BINARY ENCODING
</H3>
The rest of this chapter consists of a detailed description
of the Z380 CPU instructions, arranged in alphabetical
order by mnemonic. This section describes the notational
conventions used in the instruction descriptions and the
binary encoding for register fields within the instruction's
operation codes (opcodes).
<BR><P>

The description of each instruction begins on a new page.
The instruction mnemonic and name are printed in bold
letters at the top of each page to enable the reader to easily
locate a desired description. The assembly language
syntax is then given in a single generic form that covers all
the variants of the instruction, along with a list of applicable
addressing modes. This is followed by a description of the
operation performed by the instruction in "pseudo Pascal"
fashion, a detailed description, a listing of all the flags that
are affected by the instruction, and illustrations of the
opcodes for all variants of the instruction.
<P><BR>

<STRONG>Symbols.</STRONG> The following symbols are used to describe the instruction set.
<P><BR>

<TABLE>
<TR><TD>n <TD>An 8-bit constant </TR>
<TR><TD>nn <TD>A 16-bit constant </TR>
<TR><TD>d <TD>An 8-bit offset. (two's complement) </TR>
<TR><TD>src <TD>Source of the instruction </TR>
<TR><TD>dst <TD>Destination of the instruction </TR>
<TR><TD>SR <TD>Select Register </TR>
<TR><TD>R <TD>Any register. In Word operation, any register pair.
     Any 8-bit register (A, B, C, D, E, H, or L) for Byte
     operation.</TR>
<TR><TD>IR <TD>Indirect register </TR>
<TR><TD>RX <TD>Indexed register (IX or IY) in Word operation, IXH,
     IXL, IYH, or IYL for Byte operation.
<TR><TD>SP <TD>Current Stack Pointer </TR>
<TR><TD>(C) <TD>I/O Port pointed by C register
<TR><TD>cc <TD>Condition Code </TR>
<TR><TD>[ ] <TD>Optional field </TR>
<TR><TD>( ) <TD>Indirect Address Pointer or Direct Address </TR>
</TABLE>
<P><BR>


Assignment of a value is indicated by the symbol ":=". For
example,
<P><BR>

     dst := dst + src
<P><BR>

indicates that the source data is added to the destination
data and the result is stored in the destination location.
<P><BR>

The symbol "{swap}" indicates that the source and destination
is swapping. For example,
<P><BR>

     dst {swap} src
<P><BR>

indicates that the source data is swapped with the data in
the destination; after the operation, data at "src" is in the
"dst" location, and data in "dst" is in the "src" location.
<P><BR>


The notation "dst (b)" is used to refer to bit "b" of a given
location, "dst(m..n)" is used to refer to bit location m to n of
the destination. For example,
<P><BR>

HL( 7) specifies bit 7 of the destination. <BR>
and <BR>
HL( 23..16) specifies bit location 23 to 16 of the HL register.
<P><BR>

<STRONG>Flags.</STRONG> The F register contains the following flags
followed by symbols.
<P><BR>

<TABLE>
<TR><TD>S <TD>Sign Flag </TR>
<TR><TD>Z <TD>Zero Flag </TR>
<TR><TD>H <TD>Half Carry Flag </TR>
<TR><TD>P/<TD>V Parity/Overflow Flag </TR>
<TR><TD>N <TD>Add/Subtract Flag </TR>
<TR><TD>C <TD>Carry Flag </TR>
</TABLE>

<H5><A name="p18"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-18:</A></H5>
<BR><P>

<H4>5.6 NOTATION AND BINARY ENCODING (Continued)
</H4>
Condition Codes. The following symbols describe the condition codes.
<BR><P>

<TABLE>
<TR><TD>Z <TD>Zero* </TR>
<TR><TD>NZ <TD>Not Zero* </TR>
<TR><TD>C <TD>Carry* </TR>
<TR><TD>NC <TD>No Carry* </TR>
<TR><TD>S <TD>Sign </TR>
<TR><TD>NS <TD>No Sign </TR>
<TR><TD>NV <TD>No Overflow </TR>
<TR><TD>V <TD>Overflow </TR>
<TR><TD>PE <TD>Parity Even </TR>
<TR><TD>PO <TD>Parity Odd </TR>
<TR><TD>P <TD>Positive </TR>
<TR><TD>M <TD>Minus </TR>
</TABLE>
<P><BR>

*Abbreviated set
Field Encoding. For opcode binary format in the Tables, use the following convention:
<P><BR>


For example, to get the opcode format on the instruction
LD (IX+ 12h), C
<P><BR>


First, find out the entry for "LD (XY+ d), R". That entry has
a opcode format of
<P><BR>


11 y11 101 01 110 -r-:= d Æ
<P><BR>


On the bottom of the each instruction, there are the field
encodings, if applicable. For the cases which call out "per
convention," then use the following encoding:
<P><BR>


<TABLE>
<TR><TD>r <TD>Reg </TR>
<TR><TD>000 <TD>B </TR>
<TR><TD>001 <TD>C </TR>
<TR><TD>010 <TD>D </TR>
<TR><TD>011 <TD>E </TR>
<TR><TD>100 <TD>H </TR>
<TR><TD>101 <TD>L </TR>
<TR><TD>111 <TD>A </TR>
</TABLE>
<P><BR>


To form the opcode, first, look for the "y" field value for IX
register, which is 0.
<P><BR>


Then find "r" field value for the C register, which is 001.
Replace "y" and "r" field with the value from the table,
replace "d" value with the real number. The results being:
<P><BR>


<TABLE>
<TR><TH>76 <TH>543 <TH>210 <TH></TH> <TH>HEX </TR>
<TR><TD>11 <TD>011 <TD>101 <TD></TD><TD>DD  </TR>
<TR><TD>01 <TD>110 <TD>001 <TD></TD><TD>71  </TR>
<TR><TD>00 <TD>010 <TD>010 <TD></TD><TD>12  </TR>
</TABLE>
<P><BR>


<H3>5.7 EXECUTION TIME
</H3>
<P><BR>

i in the execution time column indicates an I/O read operation. The time required for a read operation is shown
<P><BR>


in the Table 5-18 below.
o in the execution time column indicates an I/O write operation. The time required for a write operation is shown
in the Table 5-18 below.
All entries in the table below assume no wait states. The
number of wait states per operation must be added to
these numbers.
<P><BR>


Table 5-18 details the execution time for each instruction
encoding. All execution times are for instruction execution
only. Clock cycles required for fetch and decode are not
included because most of the time the clocks required for
these operations occur in parallel with execution of the
previous instruction( s).
<P><BR>


r in the execution time column indicates a memory read operation. The time required for a read operation is shown
in the Table 5-18 below.
<BR>
w in the execution time column indicates a memory write operation. The time required for a write operation is shown
in the Table 5-18 below.
<P><BR>


<H5><A name="p19"
Z380 tm USER'S MANUAL
DC-8297-03 ZILOG>page 5-19:</A></H5>
<BR><P>

<TABLE BORDER>
<CAPTION ALIGN=TOP>
Table 5-18. Execution Time
</CAPTION>
<TR><TH>Operation <TH>Byte <TH>Word <TH>Word <TH>Long <TH>Long <TH>Long <TH>Long <TH>Long </TR>
<TR><TD></TD></TR>
<TR><TD>Sequence <TD>B <TD>W <TD>B/B <TD>W/W <TD>W/B/B <TD>B/W/B <TD>B/B/W <TD>B/B/B/B </TR>
<TR><TD>Memory Read <TD>3..4 <TD>3..4 <TD>5..6 <TD>5..6 <TD>7..8 <TD>7..8 <TD>7..8 <TD>9..10 </TR>
<TR><TD>Memory Write <TD>0..1 <TD>0..1 <TD>2..3 <TD>2..3 <TD>4..5 <TD>4..5 <TD>4..5 <TD>6..7 </TR>
<TR><TD>Internal I/O Read <TD>34 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD></TD></TR>
<TR><TD>Internal I/O Write <TD>0..1 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>1X External I/O Read <TD>4..5 <TD>4..5 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>1X External I/O Write <TD>1..2 <TD>1..2 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>2X External I/O Read <TD>9..11 <TD>9..11 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>2X External I/O Write <TD>1..3 <TD>1..3 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD></TD></TR>
<TR><TD>4X External I/O Read <TD>17..21 <TD>17..21 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>4X External I/O Write <TD>1..5 <TD>1..5 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>6X External I/O Read <TD>25..31 <TD>25..31 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>6X External I/O Write <TD>1..7 <TD>1..7 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>8X External I/O Read <TD>33..41 <TD>33..41 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
<TR><TD>8X External I/O Write <TD>1..9 <TD>1..9 <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A <TD>N/A </TR>
</TABLE>


Note: Units are in Clocks. "N/ A" is not applicable for that particular transaction.
<P><BR>

</BODY>
</HTML>

<!-- <SERVICE NAME="pop"> -->
<SCRIPT LANGUAGE="javascript">
<!-- 
var cuid= "9639"; var keywords= "family^theme*parks"; 
// -->
</SCRIPT>
<SCRIPT LANGUAGE="javascript" SRC="http://adforce.imgis.com/?addyn|2.0|25|13007|1|16|key=family^theme*parks;misc=122471982;">
<!--
var urlOfNewPop= "http://www.geocities.com/ad_container/pop.html?cuid="+cuid+"&keywords="+keywords; oldPop= window.open(urlOfNewPop, '_popIt', 'width=515,height=125'); if (oldPop.location.href != urlOfNewPop) {  if ((navigator.appName == "Netscape") && (parseInt(navigator.appVersion) == 3)) { setTimeout("oldPop.close()", 750); setTimeout("window.open(urlOfNewPop, '_popIt', 'width=515,height=125')", 1700); } else { oldPop.close(); setTimeout("window.open(urlOfNewPop, '_popIt', 'width=515,height=125')", 1000); } } 
// -->
</SCRIPT>
<!-- </SERVICE> -->

<!-- <SERVICE NAME="watermark"> -->
<DIV CLASS="GeoBrandingV2" ID="GeoBrandingV2" STYLE="position:absolute;top:1;display:none;" ALIGN="right"><A HREF="http://www.geocities.com/?source=watermark&browser=MSIE" TARGET="_top"><IMG SRC="http://pic.geocities.com/images/watermark/v1/geocities.gif" ALT="Click Here!" WIDTH="107" HEIGHT="41" BORDER="0"></A></DIV><DIV CLASS="nh1" ID="nh1" STYLE="position:absolute;display:none;height:168;font-family:arial,helvetica,sans-serif;background-color:cccccc;color:cccccc;text-align:left;border-style:solid;border-color:ffffff;border-width:2;"><STYLE TYPE="text/css"><!--a.menu {color:000000;}a.menu:hover {color:cc0000;}--></STYLE><DIV ID="nada" STYLE="position:absolute;display:none;height:19;top:1;color:ffffff;font-weight:bold;font-family:arial,helvetica,sans-serif;font-size:14px;text-align:center;"><A HREF="http://www.geocities.com/join/?source=watermark&browser=MSIE" style="color:ffffff;" onMouseOver="window.status='';return true;" onMouseOut="window.status='';return true;" target="_top">Build Your Free Home Page</a></DIV><DIV ID="hr" STYLE="position:absolute;display:none;height:19;top:1;color:000000;font-weight:bold;font-size:14px;text-align:center;">Visit&nbsp;other&nbsp;great&nbsp;pages&nbsp;on:</DIV><DIV STYLE="position:absolute;display:none;height:19;top:1;font-family:arial,helvetica,sans-serif;color:000000;font-size:12px;font-weight:normal;font-style:normal;"><A CLASS="menu" HREF="http://www.geocities.com/Avenues/Travel/?source=watermark&browser=MSIE" onMouseOver="window.status='';return true;" onMouseOut="window.status='';return true;" target="_top">Travel</a>&gt;</div>Travel<DIV STYLE="position:absolute;display:none;height:19;top:1;font-family:arial,helvetica,sans-serif;color:000000;font-size:12px;font-weight:normal;font-style:normal;"><A CLASS="menu" HREF="http://www.geocities.com/Avenues/Travel/Planning/?source=watermark&browser=MSIE" onMouseOver="window.status='';return true;" onMouseOut="window.status='';return true;" target="_top">Planning</a>&gt;</div>Planning<DIV STYLE="position:absolute;display:none;height:19;top:1;font-family:arial,helvetica,sans-serif;color:000000;font-size:12px;font-weight:normal;font-style:normal;"><A CLASS="menu" HREF="http://www.geocities.com/Avenues/Travel/Planning/Family/?source=watermark&browser=MSIE" onMouseOver="window.status='';return true;" onMouseOut="window.status='';return true;" target="_top">Family</a>&gt;</div>Family<DIV STYLE="position:absolute;display:none;height:19;top:1;font-family:arial,helvetica,sans-serif;color:000000;font-size:12px;font-weight:normal;font-style:normal;"><A CLASS="menu" HREF="http://www.geocities.com/Avenues/Travel/Planning/Family/Theme_Parks/?source=watermark&browser=MSIE" onMouseOver="window.status='';return true;" onMouseOut="window.status='';return true;" target="_top">Theme Parks</a></div>Theme Parks</DIV>
<SCRIPT LANGUAGE="javascript1.2" SRC="http://www.geocities.com/include/watermark/v2/ms.js">
</SCRIPT>
<!-- </SERVICE> -->
